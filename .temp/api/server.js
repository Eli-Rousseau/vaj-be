"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GLOBAL_AUTOGENERATED_FIELDS = void 0;
const express_1 = __importDefault(require("express"));
const logger_1 = __importDefault(require("../utils/logger"));
const stage_1 = require("../utils/stage");
const database_1 = require("../utils/database");
const user_1 = __importDefault(require("./routes/database/user"));
const system_authentication_1 = __importDefault(require("./routes/database/system_authentication"));
// Define the global autogenerated fields
exports.GLOBAL_AUTOGENERATED_FIELDS = [
    "created_at",
    "updated_at",
];
// Define the fixed variables for rate limiting
const RATE_WINDOW_MS = 60000; // 1 minute
const RATE_THRESHOLD = 1000;
// Initialize the global variables
const PORT = 1111;
// Define the app variable
let app;
// Setting up the server process
async function setupServer() {
    // Loading the stage variable
    await (0, stage_1.loadStage)();
    // Creating a postgresql client
    const pgClient = (0, database_1.createPgClient)();
    // Initiating a connection with the pgClient
    await (0, database_1.initializeDatabaseConnection)(pgClient);
    // Skip server listening
    if (!(0, database_1.isConnectedToDatabase)()) {
        logger_1.default.info("Skipping the server listening.");
        process.exit(1);
    }
    // Setup a database healthcheck on defined intervals
    setInterval(() => (0, database_1.checkDatabaseHealth)(pgClient), 3600000); // 1 hour
    // Initiate the api server
    app = (0, express_1.default)();
    // See whether request is signed with a registered API key
    app.use((req, res, next) => {
        // Fetch the request API key
        const reqAPIKey = req.headers["x-api-key"];
        // Retrieve all the API keys present in the environmental variables
        let APIKeys = {};
        for (const [key, value] of Object.entries(process.env)) {
            if (/VAJ_API_KEY/.test(key) && value !== undefined) {
                APIKeys[key] = value;
            }
        }
        // Check to see if the request API key is present in the list of registered API keys
        if (!reqAPIKey ||
            Array.isArray(reqAPIKey) ||
            !Object.values(APIKeys).includes(reqAPIKey)) {
            res.status(403).json({ error: "Forbidden: Invalid API Key" }).end();
            return;
        }
        next();
    });
    // Checks to see the status of the database
    app.use(async (req, res, next) => {
        if (!(0, database_1.isConnectedToDatabase)()) {
            logger_1.default.info("Attempting new connection to the database.");
            await (0, database_1.initializeDatabaseConnection)(pgClient);
            if (!database_1.isConnectedToDatabase) {
                res
                    .status(503)
                    .json({ error: "Service unavailable: database is unreachable." })
                    .end();
                return;
            }
        }
        next();
    });
    // Rate limiting the requests using a global fixed window counter strategy
    let requestCounter = 0;
    let windowStart = Date.now();
    app.use((req, res, next) => {
        const now = Date.now();
        if (now - windowStart > RATE_WINDOW_MS) {
            // Reset the window
            windowStart = now;
            requestCounter = 0;
        }
        requestCounter++;
        if (requestCounter > RATE_THRESHOLD) {
            res
                .status(429)
                .json({ error: "Rate limit exceeded. Please try again later." })
                .end();
            return;
        }
        next();
    });
    // Parse the incoming JSON bodies
    app.use(express_1.default.json());
    // Handeling the query parameters
    app.use((req, res, next) => {
        // Handeling the limit query parameter
        let limit = undefined;
        if (typeof req.query.limit === "string") {
            limit = req.query.limit;
        }
        req.limit = limit;
        // Handeling the offset query parameter
        let offset = undefined;
        if (typeof req.query.offset === "string") {
            offset = req.query.offset;
        }
        req.offset = offset;
        next();
    });
    // Adding the routers
    app.use("/database/user", user_1.default);
    app.use("/database/system_authentication", system_authentication_1.default);
    // Catching requests to undefined routes
    app.use((req, res, next) => {
        res
            .status(404)
            .json({ error: `Route '${req.originalUrl}' not found.` })
            .end();
        return;
    });
}
// Starting up the server process
async function startServer() {
    // Start the listen process
    app.listen(PORT, () => {
        // Load the host and the port
        const host = process.env.DATABASE_HOST;
        if (!host) {
            logger_1.default.error("Unable to retrieve the database host from the environmental variables.");
            process.exit(1);
        }
        logger_1.default.info(`Server listening at http://${host}:${PORT}`);
    });
}
// On terminating the server process
function terminateServer() {
    process.on("SIGINT", async () => {
        logger_1.default.info("Received SIGINT. Terminating the server process. Cleaning up...");
        await (0, database_1.terminateDatabaseConnection)();
        process.exit((0, database_1.isConnectedToDatabase)() ? 0 : 1);
    });
    process.on("SIGTERM", async () => {
        logger_1.default.info("Received SIGTERM. Terminating the server process. Cleaning up...");
        await (0, database_1.terminateDatabaseConnection)();
        process.exit((0, database_1.isConnectedToDatabase)() ? 0 : 1);
    });
}
// Orchestrate the server creation process
(async () => {
    await setupServer(); // Wait until setup is done
    startServer(); // Then start the listener
    terminateServer(); // Setup graceful shutdown
})();
//# sourceMappingURL=server.js.map