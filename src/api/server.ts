import express from "express";
import { Express } from "express";

import Logger from "../utils/logger";
import { loadStage } from "../utils/stage";
import {
  getPgClient,
  initializeDatabaseConnection,
  terminateDatabaseConnection,
  isConnectedToDatabase,
  checkDatabaseHealth,
} from "../utils/database";
import { Client } from "pg";
import {
  databaseAddressRoute,
  databaseArticleRoute,
  databaseArticleParentCategoryRoute,
  databaseArticleSubCategoryRoute,
  databaseAvailabilityRoute,
  databaseBrandRoute,
  databaseColorRoute,
  databaseConditionRoute,
  databaseCurrencyRoute,
  databaseDiscountCouponRoute,
  databaseGenderRoute,
  databaseMaterialRoute,
  databaseOrderRoute,
  databaseOrderArticleRoute,
  databaseOrderStatusRoute,
  databaseOrderTypeRoute,
  databasePaymentMethodRoute,
  databaseSeasonRoute,
  databaseSizeRoute,
  databaseSystemAuthenticationRoute,
  databaseSystemPermissionRoute,
  databaseSystemRoleRoute,
  databaseSystemRolePermissionRoute,
  databaseUserRoute,
} from "./routes/database/index";

// Define the order by query parameter interfaces
export type Direction = "asc" | "desc";
export interface OrderByField {
  field: string;
  direction: Direction;
}

// Define the where query parameter interfaces
export type Operator = "=" | "!=" | ">" | ">=" | "<" | "<=";
export interface WhereCondition {
  field: string;
  operator: Operator;
  value: string;
}

// Extend the request and reponse interfaces
export interface ExpectedRequest extends express.Request {
  id?: string;
  limit?: string;
  offset?: string;
  orderBy?: OrderByField[];
  where?: WhereCondition[];
  pgClient?: Client;
}
export interface ExpectedResponse extends express.Response {}

// Define the global autogenerated fields
export const GLOBAL_AUTOGENERATED_FIELDS: string[] = [
  "created_at",
  "updated_at",
];

// Define the fixed variables for rate limiting
const RATE_WINDOW_MS = 60_000; // 1 minute
const RATE_THRESHOLD = 1000;

// Initialize the global variables
const PORT: number = 1111;

// Define the app variable
let app: Express;

// Setting up the server process
async function setupServer() {
  // Loading the stage variable
  await loadStage();

  // Creating a postgresql client
  const pgClient: Client | null | undefined = getPgClient();
  if (!pgClient) {
    Logger.error("Unable to retrieve the Postgres Client.");
    Logger.info("Skipping the server listening.");
    process.exit(1);
  }

  // Initiating a connection with the pgClient
  try {
    await initializeDatabaseConnection(pgClient);
  } catch (error) {
    Logger.error(`Unable to initialize database connection: ${error}`);
    process.exit(1);
  }

  // Skip server listening
  if (!isConnectedToDatabase()) {
    Logger.error("Unable to connect with the Postgres database.");
    Logger.info("Skipping the server listening.");
    process.exit(1);
  }

  // Setup a database healthcheck on defined intervals
  setInterval(() => checkDatabaseHealth(pgClient), 3600_000); // 1 hour

  // Initiate the api server
  app = express();

  // See whether request is signed with a registered API key
  app.use((req: ExpectedRequest, res: ExpectedResponse, next) => {
    // Fetch the request API key
    const reqAPIKey: string | string[] | undefined = req.headers["x-api-key"];

    // Retrieve all the API keys present in the environmental variables
    let APIKeys: Record<string, string> = {};
    for (const [key, value] of Object.entries(process.env)) {
      if (/VAJ_API_KEY/.test(key) && value !== undefined) {
        APIKeys[key] = value;
      }
    }

    // Check to see if the request API key is present in the list of registered API keys
    if (
      !reqAPIKey ||
      Array.isArray(reqAPIKey) ||
      !Object.values(APIKeys).includes(reqAPIKey)
    ) {
      res.status(403).json({ error: "Invalid API Key." }).end();
      return;
    }
    next();
  });

  // Rate limiting the requests using a global fixed window counter strategy
  let requestCounter = 0;
  let windowStart = Date.now();
  app.use((req: ExpectedRequest, res: ExpectedResponse, next) => {
    const now = Date.now();

    if (now - windowStart > RATE_WINDOW_MS) {
      // Reset the window
      windowStart = now;
      requestCounter = 0;
    }

    requestCounter++;

    if (requestCounter > RATE_THRESHOLD) {
      res
        .status(429)
        .json({ error: "Rate limit exceeded. Please try again later." })
        .end();
      return;
    }

    next();
  });

  // Parse the incoming JSON bodies
  app.use(express.json());

  // Handeling the query parameters
  app.use((req: ExpectedRequest, res: ExpectedResponse, next) => {
    // Handeling the limit query parameter
    let limit: string | undefined = undefined;
    if (typeof req.query.limit === "string") {
      limit = req.query.limit;
    }
    req.limit = limit;

    // Handeling the offset query parameter
    let offset: string | undefined = undefined;
    if (typeof req.query.offset === "string") {
      offset = req.query.offset;
    }
    req.offset = offset;

    // Handeling the orderBy query parameter
    let orderBy: OrderByField[] | undefined = undefined;
    if (typeof req.query.orderBy === "string") {
      orderBy = [];
      const parts: string[] = req.query.orderBy.split(",");

      for (const part of parts) {
        const [field, direction] = part.split(":");

        if (field && (direction === "asc" || direction === "desc")) {
          orderBy.push({ field, direction });
        }
      }
    }
    req.orderBy = orderBy;

    // Handeling the where query parameter
    let where: WhereCondition[] | undefined = undefined;
    if (typeof req.query.where === "string") {
      where = [];
      const parts: string[] = req.query.where.split(",");

      for (const part of parts) {
        const operatorMatch = part.match(/(<=|>=|!=|=|<|>)/);
        if (!operatorMatch) continue;

        const operator = operatorMatch[0] as Operator;
        const [field, value] = part.split(operator);

        if (field && value !== undefined) {
          where.push({ field, operator, value });
        }
      }
    }
    req.where = where;

    next();
  });

  // Adding the routers
  app.use("/database/address", databaseAddressRoute);
  app.use("/database/article", databaseArticleRoute);
  app.use(
    "/database/article_parent_category",
    databaseArticleParentCategoryRoute
  );
  app.use("/database/availability", databaseAvailabilityRoute);
  app.use("/database/article_sub_category", databaseArticleSubCategoryRoute);
  app.use("/database/brand", databaseBrandRoute);
  app.use("/database/color", databaseColorRoute);
  app.use("/database/condition", databaseConditionRoute);
  app.use("/database/currency", databaseCurrencyRoute);
  app.use("/database/discount_coupon", databaseDiscountCouponRoute);
  app.use("/database/gender", databaseGenderRoute);
  app.use("/database/material", databaseMaterialRoute);
  app.use("/database/order", databaseOrderRoute);
  app.use("/database/order_article", databaseOrderArticleRoute);
  app.use("/database/order_status", databaseOrderStatusRoute);
  app.use("/database/order_type", databaseOrderTypeRoute);
  app.use("/database/payment_method", databasePaymentMethodRoute);
  app.use("/database/season", databaseSeasonRoute);
  app.use("/database/size", databaseSizeRoute);
  app.use("/database/system_authentication", databaseSystemAuthenticationRoute);
  app.use("/database/system_permission", databaseSystemPermissionRoute);
  app.use("/database/system_role", databaseSystemRoleRoute);
  app.use(
    "/database/system_role_permission",
    databaseSystemRolePermissionRoute
  );
  app.use("/database/user", databaseUserRoute);

  // Catching requests to undefined routes
  app.use((req: ExpectedRequest, res: ExpectedResponse, next) => {
    res
      .status(404)
      .json({ error: `Route '${req.originalUrl}' not found.` })
      .end();
    return;
  });
}

// Starting up the server process
async function startServer() {
  // Start the listen process
  app.listen(PORT, () => {
    // Load the host and the port
    const host: string | undefined = process.env.DATABASE_HOST;
    if (!host) {
      Logger.error(
        "Unable to retrieve the database host from the environmental variables."
      );
      process.exit(1);
    }
    Logger.info(`Server listening at http://${host}:${PORT}`);
  });
}

// On terminating the server process
function terminateServer() {
  process.on("SIGINT", async () => {
    Logger.info(
      "Received SIGINT. Terminating the server process. Cleaning up..."
    );
    await terminateDatabaseConnection();
    process.exit(isConnectedToDatabase() ? 0 : 1);
  });

  process.on("SIGTERM", async () => {
    Logger.info(
      "Received SIGTERM. Terminating the server process. Cleaning up..."
    );
    await terminateDatabaseConnection();
    process.exit(isConnectedToDatabase() ? 0 : 1);
  });
}

// Orchestrate the server creation process
(async () => {
  await setupServer(); // Wait until setup is done
  startServer(); // Then start the listener
  terminateServer(); // Setup graceful shutdown
})();
