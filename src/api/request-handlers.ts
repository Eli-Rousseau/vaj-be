import { QueryResult } from "pg";
import { NextFunction } from "express";
import { instanceToPlain, plainToInstance } from "class-transformer";

import {
  ExpectedRequest,
  ExpectedResponse,
  GLOBAL_AUTOGENERATED_FIELDS,
} from "./server";
import { getPgClient } from "../utils/database";

export const routParametersHandler = function (
  req: ExpectedRequest,
  res: ExpectedResponse,
  next: NextFunction,
  value: any
): void {
  req.id = value;
  next();
};

export const getPgClientHandler = function (
  req: ExpectedRequest,
  res: ExpectedResponse,
  next: NextFunction
): void {
  try {
    req.pgClient = getPgClient();
  } catch (error) {
    res
      .status(500)
      .json({
        error: `Encountered an error when getting the postgresql client: ${error}`,
      })
      .end();
    return;
  }
  next();
};

export const getRequestOnParamRouteHandlerWrapper = function <T extends object>(
  clsName: string,
  cls: new (...args: any[]) => any
): (req: ExpectedRequest, res: ExpectedResponse) => Promise<void> {
  const getRequestOnParamRouteHandler = async function (
    req: ExpectedRequest,
    res: ExpectedResponse
  ) {
    // Retrieve the record reference
    const reference: string = req.id as string;

    // Format the database query
    const querySelectRecord: string = `
    SELECT *
    FROM shop.${clsName}
    WHERE reference = '${reference}';    
        `;

    // Run the query on the database
    let row: any;
    try {
      const queryResult: QueryResult = await req.pgClient!.query(
        querySelectRecord
      );
      row = queryResult.rows[0];
    } catch (error) {
      res
        .status(400)
        .json({
          error: `Failed to execute the query on the database: ${error}`,
          query: querySelectRecord,
        })
        .end();
      return;
    }

    // Verify whether a record could be returned
    if (!row) {
      res
        .status(400)
        .json({
          error: `No record found for identifier: ${reference}`,
          query: querySelectRecord,
        })
        .end();
      return;
    }

    // Convert record into instance
    const record: T = plainToInstance(cls, row);

    // Reconvert the instance to output
    const output: any = instanceToPlain(record);

    // Finish the response
    res.status(200).json(output).end();
    return;
  };

  return getRequestOnParamRouteHandler;
};

export const postRequestOnParamRouteHandlerWrapper = function <
  T extends object
>(
  clsName: string,
  cls: new (...args: any[]) => any
): (req: ExpectedRequest, res: ExpectedResponse) => Promise<void> {
  const postRequestOnParamRouteHandler = async function (
    req: ExpectedRequest,
    res: ExpectedResponse
  ) {
    res
      .status(400)
      .json({
        error: "Invalid request: unable to insert based on identifier.",
      })
      .end();
    return;
  };

  return postRequestOnParamRouteHandler;
};

export const putRequestOnParamRouteHandlerWrapper = function <T extends object>(
  clsName: string,
  cls: new (...args: any[]) => any
): (req: ExpectedRequest, res: ExpectedResponse) => Promise<void> {
  const putRequestOnParamRouteHandler = async function (
    req: ExpectedRequest,
    res: ExpectedResponse
  ) {
    // Retrieve the record reference
    const reference: string = req.id as string;

    // Retrieve the request body
    const body: any = req.body;

    // Verify whether the inputs is an object
    if (typeof body !== "object" || body === null || Array.isArray(body)) {
      res
        .status(400)
        .json({
          error: `Expected body with a single object. Received: ${body}`,
        })
        .end();
      return;
    }

    // Check whether this is a enum class
    let isEnumClass: boolean;
    try {
      const enumInstance: T = plainToInstance(cls, { reference: "check" });
      const fields: string[] = Object.keys(enumInstance);
      isEnumClass = fields.length === 1;
    } catch {
      isEnumClass = false;
    }
    if (isEnumClass) {
      res
        .status(400)
        .json({
          error: `Invalid request: The transformer class ${clsName} has only one field, which is interpreted as an enum. PUT requests are not supported for enum-based endpoints.`,
        })
        .end();
      return;
    }

    // Convert plain objects into instances
    let instance: T;
    try {
      instance = plainToInstance(cls, body);
    } catch (error) {
      res
        .status(400)
        .json({
          error: `Failed to tranform the plain object into an class instance: ${error}`,
          record: body,
        })
        .end();
      return;
    }

    // Filter out the autogenerated fields to exclude
    let fields: string[] = Object.keys(instance);
    fields = fields.filter(
      (field) =>
        !GLOBAL_AUTOGENERATED_FIELDS.includes(field) &&
        !["reference"].includes(field)
    );

    // Reconvert the instances to plain
    const plain: Record<string, any> = instanceToPlain(instance);

    // Retrieve all the record values
    const recordValues: string[] = fields.map((field) => {
      return `${field} = ${
        plain[field] === null
          ? "NULL"
          : typeof plain[field] === "string"
          ? `'${plain[field]}'`
          : plain[field]
      }`;
    });

    // Format the database query
    const queryUpdateRecord: string = `
    UPDATE shop.${clsName}
    SET ${recordValues.join(",\n")}
    WHERE reference = ${reference}
    RETURNING *;    
        `;

    // Run the query on the database
    let row: any;
    try {
      const queryResult: QueryResult = await req.pgClient!.query(
        queryUpdateRecord
      );
      row = queryResult.rows[0];
    } catch (error) {
      res
        .status(400)
        .json({
          error: `Failed to execute the query on the database: ${error}`,
          query: queryUpdateRecord,
        })
        .end();
      return;
    }

    // Verify whether a record could be returned
    if (!row) {
      res
        .status(400)
        .json({
          error: `No record found for identifier: ${reference}`,
          query: queryUpdateRecord,
        })
        .end();
      return;
    }

    // Convert record into instance
    const record: T = plainToInstance(cls, row);

    // Reconvert the instance to output
    const output: any = instanceToPlain(record);

    // Finish the response
    res.status(200).json(output).end();
    return;
  };

  return putRequestOnParamRouteHandler;
};

export const deleteRequestOnParamRouteHandlerWrapper = function <
  T extends object
>(
  clsName: string,
  cls: new (...args: any[]) => any
): (req: ExpectedRequest, res: ExpectedResponse) => Promise<void> {
  const deleteRequestOnParamRouteHandler = async function (
    req: ExpectedRequest,
    res: ExpectedResponse
  ) {
    // Retrieve the record reference
    const reference: string = req.id as string;

    // Format the database query
    const queryDeleteInstance: string = `
    DELETE FROM shop.${clsName}
    WHERE reference = '${reference}'
    RETURNING *;    
        `;

    // Run the query on the database
    let row: any;
    try {
      const queryResult: QueryResult = await req.pgClient!.query(
        queryDeleteInstance
      );
      row = queryResult.rows[0];
    } catch (error) {
      res
        .status(400)
        .json({
          error: `Failed to execute the query on the database: ${error}`,
          query: queryDeleteInstance,
        })
        .end();
      return;
    }

    // Verify whether a record could be returned
    if (!row) {
      res
        .status(400)
        .json({
          error: `No record found for identifier: ${reference}`,
          query: queryDeleteInstance,
        })
        .end();
      return;
    }

    // Convert record into instance
    const record: T = plainToInstance(cls, row);

    // Reconvert the instance to output
    const output: any = instanceToPlain(record);

    // Finish the response
    res.status(200).json(output).end();
    return;
  };

  return deleteRequestOnParamRouteHandler;
};

export const getRequestOnMainRouteHandlerWrapper = function <T extends object>(
  clsName: string,
  cls: new (...args: any[]) => any
): (req: ExpectedRequest, res: ExpectedResponse) => Promise<void> {
  const getRequestOnMainRouteHandler = async function (
    req: ExpectedRequest,
    res: ExpectedResponse
  ) {
    // Retrieve the query params
    const limit: string | undefined = req.limit;
    const offset: string | undefined = req.offset;

    // Format the database query
    const querySelectRecords: string = `
        SELECT *
        FROM shop.${clsName}
        ${limit ? "LIMIT " + limit + (offset ? " OFFSET " + offset : "") : ""};
            `;

    // Run the query on the database
    let rows: any[] = [];
    try {
      const queryResult: QueryResult = await req.pgClient!.query(
        querySelectRecords
      );
      rows = queryResult.rows;
    } catch (error) {
      res
        .status(400)
        .json({
          error: `Failed to execute the query on the database: ${error}`,
          query: querySelectRecords,
        })
        .end();
      return;
    }

    // Verify whether one or more records could be returned
    if (!rows) {
      res
        .status(400)
        .json({
          error:
            "No records could be retrieved upon execution of the database query.",
          query: querySelectRecords,
        })
        .end();
      return;
    }

    // Convert records into instances
    let records: T[] = [];
    for (let i: number = 0; i < rows.length; i++) {
      const row: any = rows[i];
      const record: T = plainToInstance(cls, row);
      records.push(record);
    }

    // Reconvert the instances to outputs
    let outputs: any[] = [];
    for (let i: number = 0; i < records.length; i++) {
      const record: T = records[i];
      const output: Record<string, any> = instanceToPlain(record);
      outputs.push(output);
    }

    // Finish the response
    res.status(200).json(outputs).end();
    return;
  };

  return getRequestOnMainRouteHandler;
};

export const postRequestOnMainRouteHandlerWrapper = function <T extends object>(
  clsName: string,
  cls: new (...args: any[]) => any
): (req: ExpectedRequest, res: ExpectedResponse) => Promise<void> {
  const postRequestOnMainRouteHandler = async function (
    req: ExpectedRequest,
    res: ExpectedResponse
  ) {
    // Retrieve the request body
    let body: any = req.body;

    // Verify whether the inputs is an array
    const inputIsArray: boolean = Array.isArray(body);
    const inputIsObject: boolean = typeof body === "object";
    if (!inputIsArray && !inputIsObject) {
      res
        .status(400)
        .json({
          error: `Expected body with a single instance or an array of ${clsName}. Received: ${body}`,
        })
        .end();
      return;
    }

    // Transform object into a list of objects
    if (!inputIsArray) {
      body = [body];
    }

    // Convert plain objects into instances
    let instances: T[] = [];
    for (let i: number = 0; i < body.length; i++) {
      const plain: any = body[i];
      try {
        const instance: T = plainToInstance(cls, plain);
        instances.push(instance);
      } catch (error) {
        res
          .status(400)
          .json({
            error: `Failed to tranform the plain object into an class instance: ${error}`,
            record: plain,
          })
          .end();
        return;
      }
    }

    // Filter out the autogenerated fields to exclude
    let fields: string[] = Object.keys(instances[0]);
    fields = fields.filter(
      (field) =>
        (field === "reference" && fields.length === 1) ||
        (field !== "reference" && !GLOBAL_AUTOGENERATED_FIELDS.includes(field))
    );

    // Reconvert the instances to plain
    let plains: Record<string, any>[] = [];
    for (let i: number = 0; i < instances.length; i++) {
      const instance: T = instances[i];
      const plain: Record<string, any> = instanceToPlain(instance);
      plains.push(plain);
    }

    // Retrieve all the record values
    let valuesRecords: string[] = [];
    for (let i: number = 0; i < plains.length; i++) {
      const plain: Record<string, any> = plains[i];
      const valuesRecord: string[] = fields.map((field) =>
        plain[field] === undefined
          ? "DEFAULT"
          : plain[field] === null
          ? "NULL"
          : typeof plain[field] === "string"
          ? `'${plain[field]}'`
          : plain[field]
      );
      valuesRecords.push(`(${valuesRecord.join(", ")})`);
    }

    // Format the database query
    const queryInsertInstances: string = `
    INSERT INTO shop.${clsName} (${fields.join(", ")})
    VALUES
    ${valuesRecords.join(",\n")}
    RETURNING *;
        `;

    // Run the query on the database
    let rows: any[] = [];
    try {
      const queryResult: QueryResult = await req.pgClient!.query(
        queryInsertInstances
      );
      rows = queryResult.rows;
    } catch (error) {
      res
        .status(400)
        .json({
          error: `Failed to execute the query on the database: ${error}`,
          query: queryInsertInstances,
        })
        .end();
      return;
    }

    // Verify whether one or more records could be returned
    if (!rows) {
      res
        .status(400)
        .json({
          error:
            "No records could be retrieved upon execution of the database query.",
          query: queryInsertInstances,
        })
        .end();
      return;
    }

    // Convert records into instances
    let records: T[] = [];
    for (let i: number = 0; i < rows.length; i++) {
      const row: any = rows[i];
      const record: T = plainToInstance(cls, row);
      records.push(record);
    }

    // Reconvert the instances to outputs
    let outputs: any[] = [];
    for (let i: number = 0; i < records.length; i++) {
      const record: T = records[i];
      const output: Record<string, any> = instanceToPlain(record);
      outputs.push(output);
    }

    // Retransform list of objects into an single object
    if (!inputIsArray) {
      outputs = outputs[0];
    }

    // Finish the response
    res.status(200).json(outputs).end();
    return;
  };

  return postRequestOnMainRouteHandler;
};

export const putRequestOnMainRouteHandlerWrapper = function <T extends object>(
  clsName: string,
  cls: new (...args: any[]) => any
): (req: ExpectedRequest, res: ExpectedResponse) => Promise<void> {
  const putRequestOnMainRouteHandler = async function (
    req: ExpectedRequest,
    res: ExpectedResponse
  ) {
    // Retrieve the request body
    let body: any = req.body;

    // Verify whether the inputs is an array
    const inputIsArray: boolean = Array.isArray(body);
    const inputIsObject: boolean = typeof body === "object";
    if (!inputIsArray && !inputIsObject) {
      res
        .status(400)
        .json({
          error: `Expected body with a single instance or an array of ${clsName}. Received: ${body}`,
        })
        .end();
      return;
    }

    // Check whether this is a enum class
    let isEnumClass: boolean;
    try {
      const enumInstance: T = plainToInstance(cls, { reference: "check" });
      const fields: string[] = Object.keys(enumInstance);
      isEnumClass = fields.length === 1;
    } catch {
      isEnumClass = false;
    }
    if (isEnumClass) {
      res
        .status(400)
        .json({
          error: `Invalid request: The transformer class ${clsName} has only one field, which is interpreted as an enum. PUT requests are not supported for enum-based endpoints.`,
        })
        .end();
      return;
    }

    // Transform object into a list of objects
    if (!inputIsArray) {
      body = [body];
    }

    // Convert plain objects into instances
    let instances: T[] = [];
    for (let i: number = 0; i < body.length; i++) {
      const plain: any = body[i];
      try {
        const instance: T = plainToInstance(cls, plain);
        instances.push(instance);
      } catch (error) {
        res
          .status(400)
          .json({
            error: `Failed to tranform the plain object into an class instance: ${error}`,
            record: plain,
          })
          .end();
        return;
      }
    }

    // Filter out the autogenerated fields to exclude
    let fields: string[] = Object.keys(instances[0]);
    fields = fields.filter(
      (field) => !GLOBAL_AUTOGENERATED_FIELDS.includes(field)
    );

    // Reconvert the instances to plain
    let plains: Record<string, any>[] = [];
    for (let i: number = 0; i < instances.length; i++) {
      const instance: T = instances[i];
      const plain: Record<string, any> = instanceToPlain(instance);
      plains.push(plain);
    }

    // Retrieve all the record values
    let valuesRecords: string[] = [];
    for (let i: number = 0; i < plains.length; i++) {
      const plain: Record<string, any> = plains[i];
      const valuesRecord: string[] = fields.map((field) =>
        plain[field] === null
          ? "NULL"
          : typeof plain[field] === "string"
          ? `'${plain[field]}'`
          : plain[field]
      );
      valuesRecords.push(`(${valuesRecord.join(", ")})`);
    }

    // Retrieve all the fields to update
    const updateFields: string[] = [];
    for (let i: number = 0; i < fields.length; i++) {
      const field: string = fields[i];
      if (field === "reference") {
        continue;
      }

      updateFields.push(`${field} = temp_updates.${field}`);
    }

    // Format the database queries
    const queryDropTemporaryTable: string = `
    DROP TABLE IF EXISTS temp_updates;
        `;
    const queryCreateTemporaryTable: string = `
    CREATE TEMP TABLE temp_updates 
    (LIKE shop."${clsName}" INCLUDING DEFAULTS INCLUDING CONSTRAINTS);
        `;
    const queryInsertinstances: string = `
    INSERT INTO temp_updates (${fields.join(", ")})
    VALUES
    ${valuesRecords.join(",\n")};    
        `;
    const queryUpdateInstances: string = `
    UPDATE shop."${clsName}"
    SET
    ${updateFields.join(",\n")}
    FROM temp_updates
    WHERE "${clsName}".reference = temp_updates.reference
    RETURNING "${clsName}".*;
        `;

    // Run the query on the database
    let rows: any[] = [];
    try {
      await req.pgClient!.query(queryDropTemporaryTable);
      await req.pgClient!.query(queryCreateTemporaryTable);
      await req.pgClient!.query(queryInsertinstances);
      const queryResult: QueryResult = await req.pgClient!.query(
        queryUpdateInstances
      );
      rows = queryResult.rows;
    } catch (error) {
      res
        .status(400)
        .json({
          error: `Failed to execute the query on the database: ${error}`,
          query: queryUpdateInstances,
        })
        .end();
      return;
    }

    // Verify whether one or more records could be returned
    if (!rows) {
      res
        .status(400)
        .json({
          error:
            "No records could be retrieved upon execution of the database query.",
          query: queryUpdateInstances,
        })
        .end();
      return;
    }

    // Convert records into instances
    let records: T[] = [];
    for (let i: number = 0; i < rows.length; i++) {
      const row: any = rows[i];
      const record: T = plainToInstance(cls, row);
      records.push(record);
    }

    // Reconvert the instances to outputs
    let outputs: any[] = [];
    for (let i: number = 0; i < records.length; i++) {
      const record: T = records[i];
      const output: Record<string, any> = instanceToPlain(record);
      outputs.push(output);
    }

    // Retransform list of objects into an single object
    if (!inputIsArray) {
      outputs = outputs[0];
    }

    // Finish the response
    res.status(200).json(outputs).end();
    return;
  };

  return putRequestOnMainRouteHandler;
};

export const deleteRequestOnMainRouteHandlerWrapper = function <
  T extends object
>(
  clsName: string,
  cls: new (...args: any[]) => any
): (req: ExpectedRequest, res: ExpectedResponse) => Promise<void> {
  const deleteRequestOnMainRouteHandler = async function (
    req: ExpectedRequest,
    res: ExpectedResponse
  ) {
    // Retrieve the request body
    let body: any = req.body;

    // Verify whether the inputs is an array
    const inputIsArray: boolean = Array.isArray(body);
    const inputIsObject: boolean = typeof body === "object";
    if (!inputIsArray && !inputIsObject) {
      res
        .status(400)
        .json({
          error: `Expected body with a single instance or an array of ${clsName}. Received: ${body}`,
        })
        .end();
      return;
    }

    // Transform object into a list of objects
    if (!inputIsArray) {
      body = [body];
    }

    // Convert plain objects into instances
    let instances: T[] = [];
    for (let i: number = 0; i < body.length; i++) {
      const plain: any = body[i];
      try {
        const instance: T = plainToInstance(cls, plain);
        instances.push(instance);
      } catch (error) {
        res
          .status(400)
          .json({
            error: `Failed to tranform the plain object into an class instance: ${error}`,
            record: plain,
          })
          .end();
        return;
      }
    }

    // Filter out the autogenerated fields to exclude
    let fields: string[] = Object.keys(instances[0]);
    fields = fields.filter(
      (field) => !GLOBAL_AUTOGENERATED_FIELDS.includes(field)
    );

    // Reconvert the instances to plain
    let plains: Record<string, any>[] = [];
    for (let i: number = 0; i < instances.length; i++) {
      const instance: T = instances[i];
      const plain: Record<string, any> = instanceToPlain(instance);
      plains.push(plain);
    }

    // Retrieve all the record references
    let referencesRecords: string[] = [];
    for (let i: number = 0; i < plains.length; i++) {
      const plain: Record<string, any> = plains[i];
      const referenceRecord: string = plain["reference"];
      referencesRecords.push(`'${referenceRecord}'`);
    }

    // Format the database query
    const queryDeleteInstances: string = `
    DELETE FROM shop.${clsName}
    WHERE reference IN (${referencesRecords.join(", ")})
    RETURNING *;    
        `;

    // Run the query on the database
    let rows: any[] = [];
    try {
      const queryResult: QueryResult = await req.pgClient!.query(
        queryDeleteInstances
      );
      rows = queryResult.rows;
    } catch (error) {
      res
        .status(400)
        .json({
          error: `Failed to execute the query on the database: ${error}`,
          query: queryDeleteInstances,
        })
        .end();
      return;
    }

    // Verify whether one or more records could be returned
    if (!rows) {
      res
        .status(400)
        .json({
          error:
            "No records could be retrieved upon execution of the database query.",
          query: queryDeleteInstances,
        })
        .end();
      return;
    }

    // Convert records into instances
    let records: T[] = [];
    for (let i: number = 0; i < rows.length; i++) {
      const row: any = rows[i];
      const record: T = plainToInstance(cls, row);
      records.push(record);
    }

    // Reconvert the instances to outputs
    let outputs: any[] = [];
    for (let i: number = 0; i < records.length; i++) {
      const record: T = records[i];
      const output: Record<string, any> = instanceToPlain(record);
      outputs.push(output);
    }

    // Retransform list of objects into an single object
    if (!inputIsArray) {
      outputs = outputs[0];
    }

    // Finish the response
    res.status(200).json(outputs).end();
    return;
  };

  return deleteRequestOnMainRouteHandler;
};
