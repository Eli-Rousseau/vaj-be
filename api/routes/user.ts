import express from "express";
import { Router } from "express";
import { instanceToPlain, plainToInstance } from "class-transformer";

import { getPgClient } from "../../utils/database";
import {
  ExpectedRequest,
  ExpectedResponse,
  GLOBAL_AUTOGENERATED_FIELDS,
} from "../server";
import { User } from "../classes/transformer-classes";
import { QueryResult } from "pg";

const userRouter: Router = express.Router();

// Handeling the route parameters
userRouter.param(
  "id",
  (req: ExpectedRequest, res: ExpectedResponse, next, value) => {
    req.id = value;
    next();
  }
);

// Handeling the retrieval of the pgClient
userRouter.use((req: ExpectedRequest, res: ExpectedResponse, next) => {
  try {
    req.pgClient = getPgClient();
  } catch (error) {
    res.status(500).json({
      error: `Encountered an error when getting the postgresql client: ${error}`,
    });
    res.end();
  }
  next();
});

// Handle request on the param route
userRouter
  .route("/:id")
  .get((req: ExpectedRequest, res: ExpectedResponse) => {})
  .post((req: ExpectedRequest, res: ExpectedResponse) => {})
  .put((req: ExpectedRequest, res: ExpectedResponse) => {})
  .delete((req: ExpectedRequest, res: ExpectedResponse) => {});

// Handle request on the main route
userRouter
  .route("/")
  .get(async (req: ExpectedRequest, res: ExpectedResponse) => {
    // Retrieve the query params
    const limit: string | undefined = req.limit;
    const offset: string | undefined = req.limit;

    // Format the database query
    const querySelectRecords: string = `
SELECT *
FROM shop.user
ORDER BY updated_at DESC
${limit ? "LIMIT " + limit + (offset ? " OFFSET " + offset : "") : ""};
    `;

    // Run the query on the database
    let rows: any[] = [];
    try {
      const queryResult: QueryResult = await req.pgClient!.query(
        querySelectRecords
      );
      rows = queryResult.rows;
    } catch (error) {
      res.status(400).json({
        error: `Failed to execute the query on the database: ${error}`,
        query: querySelectRecords,
      });
      res.end();
    }

    if (rows) {
      // Convert records into instances
      let records: User[] = [];
      for (let i: number = 0; i < rows.length; i++) {
        const row: any = rows[i];
        const record: User = plainToInstance(User, row);
        records.push(record);
      }

      // Reconvert the instances to outputs
      let outputs: any[] = [];
      for (let i: number = 0; i < records.length; i++) {
        const record: User = records[i];
        const output: Record<string, any> = instanceToPlain(record);
        outputs.push(output);
      }

      // Finish the response
      res.status(200).json(outputs);
      res.end();
    }
  })
  .post(async (req: ExpectedRequest, res: ExpectedResponse) => {
    // Retrieve the request body
    const body: any = req.body;

    // Verify whether the inputs is in array
    if (!Array.isArray(body)) {
      res.status(400).json({ error: "Expected an array of users" });
      res.end();
    }

    // Convert plain objects into instances
    let instances: User[] = [];
    for (let i: number = 0; i < body.length; i++) {
      const plain: any = body[i];
      try {
        const user: User = plainToInstance(User, plain);
        instances.push(user);
      } catch (error) {
        res.status(400).json({
          error: `Failed to tranform the plain object into an User instance: ${error}`,
          record: plain,
        });
        res.end();
      }
    }

    // Filter out the autogenerated fields to exclude
    let fields: string[] = Object.keys(instances[0]);
    fields = fields.filter(
      (field) => !GLOBAL_AUTOGENERATED_FIELDS.includes(field)
    );

    // Reconvert the instances to plain
    let plains: Record<string, any>[] = [];
    for (let i: number = 0; i < instances.length; i++) {
      const user: User = instances[i];
      const plain: Record<string, any> = instanceToPlain(user);
      plains.push(plain);
    }

    // Retrieve all the record values
    let valuesRecords: string[] = [];
    for (let i: number = 0; i < plains.length; i++) {
      const plain: Record<string, any> = plains[i];
      const valuesRecord: string[] = fields.map((field) =>
        plain[field] === undefined
          ? "DEFAULT"
          : plain[field] === null
          ? "NULL"
          : typeof plain[field] === "string"
          ? `'${plain[field]}'`
          : plain[field]
      );
      valuesRecords.push(`(${valuesRecord.join(", ")})`);
    }

    // Format the database query
    const queryInsertInstances: string = `
INSERT INTO shop.user (${fields.join(", ")})
VALUES
${valuesRecords.join(",\n")}
RETURNING *;
    `;

    // Run the query on the database
    let rows: any[] = [];
    try {
      const queryResult: QueryResult = await req.pgClient!.query(
        queryInsertInstances
      );
      rows = queryResult.rows;
    } catch (error) {
      res.status(400).json({
        error: `Failed to execute the query on the database: ${error}`,
        query: queryInsertInstances,
      });
      res.end();
    }

    if (rows) {
      // Convert records into instances
      let records: User[] = [];
      for (let i: number = 0; i < rows.length; i++) {
        const row: any = rows[i];
        const record: User = plainToInstance(User, row);
        records.push(record);
      }

      // Reconvert the instances to outputs
      let outputs: any[] = [];
      for (let i: number = 0; i < records.length; i++) {
        const record: User = records[i];
        const output: Record<string, any> = instanceToPlain(record);
        outputs.push(output);
      }

      // Finish the response
      res.status(200).json(outputs);
      res.end();
    }
  })
  .put(async (req: ExpectedRequest, res: ExpectedResponse) => {
    // Retrieve the request body
    const body: any = req.body;

    // Verify whether the inputs is in array
    if (!Array.isArray(body)) {
      res.status(400).json({ error: "Expected an array of users" });
      res.end();
    }

    // Convert plain objects into instances
    let instances: User[] = [];
    for (let i: number = 0; i < body.length; i++) {
      const plain: any = body[i];
      try {
        const user: User = plainToInstance(User, plain);
        instances.push(user);
      } catch (error) {
        res.status(400).json({
          error: `Failed to tranform the plain object into an User instance: ${error}`,
          record: plain,
        });
        res.end();
      }
    }

    // Filter out the autogenerated fields to exclude
    let fields: string[] = Object.keys(instances[0]);
    fields = fields.filter(
      (field) => !GLOBAL_AUTOGENERATED_FIELDS.includes(field)
    );

    // Reconvert the instances to plain
    let plains: Record<string, any>[] = [];
    for (let i: number = 0; i < instances.length; i++) {
      const user: User = instances[i];
      const plain: Record<string, any> = instanceToPlain(user);
      plains.push(plain);
    }

    // Retrieve all the record values
    let valuesRecords: string[] = [];
    for (let i: number = 0; i < plains.length; i++) {
      const plain: Record<string, any> = plains[i];
      const valuesRecord: string[] = fields.map((field) =>
        plain[field] === null
          ? "NULL"
          : typeof plain[field] === "string"
          ? `'${plain[field]}'`
          : plain[field]
      );
      valuesRecords.push(`(${valuesRecord.join(", ")})`);
    }

    // Retrieve all the fields to update
    const updateFields: string[] = [];
    for (let i: number = 0; i < fields.length; i++) {
      const field: string = fields[i];
      if (field === "reference") {
        continue;
      }

      updateFields.push(`${field} = temp_updates.${field}`);
    }

    // Format the database queries
    const queryDropTemporaryTable: string = `
DROP TABLE IF EXISTS temp_updates;
    `;
    const queryCreateTemporaryTable: string = `
CREATE TEMP TABLE temp_updates 
(LIKE shop."user" INCLUDING DEFAULTS INCLUDING CONSTRAINTS);
    `;
    const queryInsertinstances: string = `
INSERT INTO temp_updates (${fields.join(", ")})
VALUES
${valuesRecords.join(",\n")};    
    `;
    const queryUpdateInstances: string = `
UPDATE shop."user"
SET
${updateFields.join(",\n")}
FROM temp_updates
WHERE "user".reference = temp_updates.reference
RETURNING "user".*;
    `;

    // Run the query on the database
    let rows: any[] = [];
    try {
      await req.pgClient!.query(queryDropTemporaryTable);
      await req.pgClient!.query(queryCreateTemporaryTable);
      await req.pgClient!.query(queryInsertinstances);
      const queryResult: QueryResult = await req.pgClient!.query(
        queryUpdateInstances
      );
      rows = queryResult.rows;
    } catch (error) {
      res.status(400).json({
        error: `Failed to execute the query on the database: ${error}`,
        query: queryUpdateInstances,
      });
      res.end();
    }

    if (rows) {
      // Convert records into instances
      let records: User[] = [];
      for (let i: number = 0; i < rows.length; i++) {
        const row: any = rows[i];
        const record: User = plainToInstance(User, row);
        records.push(record);
      }

      // Reconvert the instances to outputs
      let outputs: any[] = [];
      for (let i: number = 0; i < records.length; i++) {
        const record: User = records[i];
        const output: Record<string, any> = instanceToPlain(record);
        outputs.push(output);
      }

      // Finish the response
      res.status(200).json(outputs);
      res.end();
    }
  })
  .delete(async (req: ExpectedRequest, res: ExpectedResponse) => {
    // Retrieve the request body
    const body: any = req.body;

    // Verify whether the inputs is in array
    if (!Array.isArray(body)) {
      res.status(400).json({ error: "Expected an array of users" });
      res.end();
    }

    // Convert plain objects into instances
    let instances: User[] = [];
    for (let i: number = 0; i < body.length; i++) {
      const plain: any = body[i];
      try {
        const user: User = plainToInstance(User, plain);
        instances.push(user);
      } catch (error) {
        res.status(400).json({
          error: `Failed to tranform the plain object into an User instance: ${error}`,
          record: plain,
        });
        res.end();
      }
    }

    // Filter out the autogenerated fields to exclude
    let fields: string[] = Object.keys(instances[0]);
    fields = fields.filter(
      (field) => !GLOBAL_AUTOGENERATED_FIELDS.includes(field)
    );

    // Reconvert the instances to plain
    let plains: Record<string, any>[] = [];
    for (let i: number = 0; i < instances.length; i++) {
      const user: User = instances[i];
      const plain: Record<string, any> = instanceToPlain(user);
      plains.push(plain);
    }

    // Retrieve all the record references
    let referencesRecords: string[] = [];
    for (let i: number = 0; i < plains.length; i++) {
      const plain: Record<string, any> = plains[i];
      const referenceRecord: string = plain['reference']
      referencesRecords.push(referenceRecord);
    }

    // Format the database queries
    const queryDeleteInstances: string = `
DELETE FROM shop.user
WHERE reference IN (${referencesRecords.join(', ')})
RETURNING *;    
    `;

    // Run the query on the database
    let rows: any[] = [];
    try {
      const queryResult: QueryResult = await req.pgClient!.query(
        queryDeleteInstances
      );
      rows = queryResult.rows;
    } catch (error) {
      res.status(400).json({
        error: `Failed to execute the query on the database: ${error}`,
        query: queryDeleteInstances,
      });
      res.end();
    }

    if (rows) {
      // Convert records into instances
      let records: User[] = [];
      for (let i: number = 0; i < rows.length; i++) {
        const row: any = rows[i];
        const record: User = plainToInstance(User, row);
        records.push(record);
      }

      // Reconvert the instances to outputs
      let outputs: any[] = [];
      for (let i: number = 0; i < records.length; i++) {
        const record: User = records[i];
        const output: Record<string, any> = instanceToPlain(record);
        outputs.push(output);
      }

      // Finish the response
      res.status(200).json(outputs);
      res.end();
    }
  });

export default userRouter;
